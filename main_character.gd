extends CharacterBody3D

# temporary
var total_inputs : int = 0
var total_physframes : int = 0

const SENS : float = 0.025
const SPEED : float = 12.42
const JUMP_VELOCITY : float = 12.42

var dashing_speed_multiplier : float = 1.42
# set based on player's equip load
var total_dash_iframes : int = 24
# set to 0 when not dashing
var curr_dash_iframe : int = 420
# dashing = true whilst dashing obv :)
var dashing : bool = false
# dash_battery_cost is the one-time immediate cost of dashing.
var dash_battery_cost : float = 420.0

# Hovering ---------------------------------------------------------------------
# Uses PD control to accurately and precisely calculate booster thrust required
var hover_height : float = 1.42
var slope_hover_err : float = 0.0
var curr_hover_err : float = 0.0
var last_hover_err : float = 0.0
var smooth_hover_derivative : float = 0.0

# PD consts
var kp : float = 69.0
var kd : float = 19.2

# obstacle probe control
var obstacle_height_probe_x_dist : float = 1.0
# ------------------------------------------------------------------------------

# cam_distance_fac stays between 0.0 and 1.0, lerps between min_cam_distance and max_cam_distance modofiable by player
var cam_distance_fac : float = 0.0001
var cam_distance_fac_delta : float = 0.01 #this is added to cam_distance_fac when input is received
var cam_distance_fac_coefficient : float = 1.1 #cam_distance_fac is multiplied/divided by this value when input is received
var cam_distance_target : float = cam_distance_fac #cam_distance_target is what's changed when input is taken, which is smoothly interpolated to in the process() function
var min_cam_distance : float = 3.2
var max_cam_distance : float = 42.0

# of seconds since last moving with wasd or left stick
var movement_timer : float = 0.0

var movement_cost_multiplier : float = 0.42

var total_parry_frames : int = 5

var defense_supercap_max : float = 1000.0
var offense_supercap_max : float = 1000.0
var battery_storage_max : float = 42000.0
var fuel_kg : float = 4200.0

# rate at which fuel can be turned into energy in kg/s 
var fuel_conversion_rate : float = 1.42
# how many kw can be generated by each kg of fuel
var fuel_conversion_efficiency : float = 442.0

var defense_supercap_curr : float = defense_supercap_max
var offense_supercap_curr : float = offense_supercap_max
var battery_storage_curr : float = battery_storage_max

var model_angle : float = 0.0

var input_vec : Vector2 = Vector2(0.0, 0.0)

# stores current vertical booster throttle 0.0-1.0
var booster_throttle : float = 0.0

var is_pounding : int = 0
var is_jumping : int = 0
var jump_input_timer : float = 0.0 # is > 0.0 when a jump input is valid
var jump_able_timer : float = 0.0 # is > 0.0 when the player character is in contact or was in contact with a jumpable surface within validity window
var jump_energy_cost : float = 42.0

# TODO: explain
var head_aim_fac : float = 0.0
var head_settled_amt : float = 0.0

var height : float = 4.2
var last_height : float = height

var last_pos : Vector3 = Vector3(0.0, 4.2, 0.0)
var target : Vector3 = Vector3 (0.0, 4.2, 0.0)

var camera_last_last_transform : Transform3D = Transform3D()
var camera_last_transform : Transform3D = Transform3D()
var camera_target_transform : Transform3D = Transform3D()

@onready var char_model: Node3D = $character_model
@onready var straight_ahead: Node3D = $character_model/straight_ahead
@onready var head: Node3D = $head
@onready var head_y_rot_target = $head_y_rot_target
@onready var body: MeshInstance3D = $character_model/body
@onready var camera_forward: Node3D = $camera_root/camera_gimbal/camera_forward
@onready var camera: Camera3D = $camera_root/camera_gimbal/camera_arm/camera
@onready var camera_target: Node3D = $camera_target
@onready var camera_gimbal: Node3D = $camera_root/camera_gimbal
@onready var camera_root: Node3D = $camera_root
@onready var camera_arm: SpringArm3D = $camera_root/camera_gimbal/camera_arm
@onready var aim_target: Node3D = $camera_root/camera_gimbal/aim_target
@onready var laser: RayCast3D = $"head/head_mesh/laser emitter/laser ðŸ˜ˆ"
@onready var body_straight_ahead: Node3D = $character_model/body_straight_ahead
@onready var tail: RayCast3D = $hitbox/tail
@onready var slope_probe_bottom: RayCast3D = $hitbox/slope_probe_bottom
@onready var slope_probe_top: RayCast3D = $hitbox/slope_probe_top
@onready var obstacle_height_probe: RayCast3D = $model_global_transform/obstacle_height_probe
@onready var ceiling_height_probe : RayCast3D = $model_global_transform/ceiling_height_probe
@onready var obstacle_distance_probe : RayCast3D = $model_global_transform/obstacle_distance_probe
@onready var obstacle_distance_probe_low : RayCast3D = $model_global_transform/obstacle_distance_probe_low
@onready var targeting_ray: RayCast3D = $camera_root/camera_gimbal/camera_arm/camera/targeting_ray



func _ready():
	Input.mouse_mode = Input.MOUSE_MODE_CAPTURED
	
func _input(event: InputEvent) -> void:
	#total_inputs += 1
	#print("inputs: ", total_inputs)
	# mouse camera movement, according to SENS constant
	if event is InputEventMouseMotion:
		rotate_y(deg_to_rad(-event.relative.x * SENS)) # rotate the character
		camera_gimbal.rotate_x(deg_to_rad(-event.relative.y * SENS)) # tilt the camera gimbal
		#char_model.rotate_y(deg_to_rad(-event.relative.x * SENS)) # rotate the model opposite our camera's rotation to keep it pointing the same direction
		camera_gimbal.rotation.x = clampf(camera_gimbal.rotation.x, deg_to_rad(-74.2), deg_to_rad(74.2)) # keep the camera from tilting up or down too much
		return
	
	elif event.is_action_pressed("lower_cam_distance"):
		cam_distance_fac -= cam_distance_fac_delta
		cam_distance_fac /= cam_distance_fac_coefficient
		cam_distance_fac = clampf(cam_distance_fac, 0.0001, 1.0)
		cam_distance_target = lerp(min_cam_distance, max_cam_distance, cam_distance_fac)
	elif event.is_action_pressed("raise_cam_distance"):
		cam_distance_fac *= cam_distance_fac_coefficient
		cam_distance_fac += cam_distance_fac_delta
		cam_distance_fac = clampf(cam_distance_fac, 0.0001, 1.0)
		#print(lerp(min_cam_distance, max_cam_distance, cam_distance_fac))
		cam_distance_target = lerp(min_cam_distance, max_cam_distance, cam_distance_fac)


func _physics_process(delta: float) -> void:
	is_pounding = 0
	if (tail != null):
		last_height = height
		height = tail.get_collision_point().distance_to(tail.global_position)
		#print(height)
	# set aim_target to the next collided object of targeting_ray, minus a bit to account for the head mesh's offset (crudely) (its good enough)
	if (targeting_ray != null):
		var target_pos: Vector3
		if !targeting_ray.is_colliding():
			target_pos = camera_forward.global_position
		else:
			target_pos = targeting_ray.get_collision_point()
		aim_target.global_position = target_pos - Vector3(0.0, 0.42, 0.0)
	# make the head look straight ahead lol- ok issa lil confugurated but it works a treat!!
	if Input.is_action_pressed("aim") or Input.is_action_pressed("fire"):
		# head_aim_fac controls the slerp between where the robot body is facing (0.0) and where the camera is pointing (1.0)
		if (head_aim_fac < 0.7):
			head_aim_fac += (18.42 * delta)
		else:
			head_aim_fac += (102.42 * delta)
	else:
		if (head_aim_fac > 1.0):
			head_aim_fac -= (62.42 * delta)
		else:
			head_aim_fac -= (14.42 * delta)
	
	# head_aim_fac is clamped to 0.0, 1.0; the slerp between straight_ahead and head_aim_halfway uses [0.0, 0.0] and the slerp from head_aim_halfway to camera_front uses [0.0, 1.0]
	head_aim_fac = clampf(head_aim_fac, 0.0, 4.5)
	# head_aim_fac is split into the y and x rotations, 0.0-0.5 and 0.5-1.0 respectively by this if statement
	if (head_aim_fac < 0.5):
		head.look_at(straight_ahead.global_position.lerp(head_y_rot_target.global_position, (head_aim_fac * 2.0)))
	else:
		head.look_at(head_y_rot_target.global_position.lerp(aim_target.global_position, ((head_aim_fac - 0.5) / 4.0)))
	
	# shift mc's head to avoid clipping into body at extreme angles looking up and down while ADSing
	head.get_node("head_mesh").position.y = lerp(0.269, 0.18, head_settled_amt)
	#print((abs(velocity.x) + abs(velocity.z)) / SPEED)
	if Input.is_action_pressed("fire") or Input.is_action_pressed("aim"):
		head.get_node("head_mesh").position.y += abs(camera_gimbal.rotation.x / 7.842)
		head_settled_amt -= 0.142
	else:
		if abs(velocity.x) <= 0.01 and abs(velocity.z) <= 0.01 and abs(velocity.y) <= 0.42:
			# head settle amount controls the resting y position of the head. it's animated with the following math:
			head_settled_amt += (0.5 - abs(head_settled_amt - 0.49999)) / 42.0
		else:
			head_settled_amt -= 0.042
	head_settled_amt = clampf(head_settled_amt, 0.0, 1.0)

# pounding ---------------------------------------------------------------------
	if Input.is_action_pressed("pound") && !Input.is_action_pressed("jump"):
		is_pounding = 1
# ------------------------------------------------------------------------------

	# Add the gravity.
	velocity += (get_gravity() + Vector3(0.0, 4.2 * booster_throttle, 0.0)) * delta * maxf(1.0, is_pounding * 8.2)
	
	# Handle jump.
	if Input.is_action_just_pressed("jump") && !is_pounding:
		jump_input_timer = 1.0
	if is_on_floor() or (height < (hover_height * 1.42)):
		jump_able_timer = 1.0
	if jump_input_timer > 0.0 && jump_able_timer > 0.0: # actually execute a jump
		jump_input_timer = 0.0
		jump_able_timer = 0.0
		velocity.y = JUMP_VELOCITY
		is_jumping = 10
		battery_storage_curr -= clampf(jump_energy_cost, 0.0, battery_storage_curr)
	jump_input_timer -= 0.042
	jump_able_timer -= 0.142
	
	if (is_jumping > 0) and (velocity.y < 0.0 or height < hover_height):
		is_jumping -= 1

	# handle booster throttle (actually more like jump enhancement at this point. TODO)
	if Input.is_action_pressed("jump") and !Input.is_action_pressed("pound"): #and (height > clampf(-(velocity.y / 4.2), 0.0, 24.2)):
		booster_throttle += 0.042
	elif !(Input.is_action_pressed("jump") and (height < 4.2)):
		booster_throttle -= 0.2
	
	booster_throttle = clampf(booster_throttle, 0.0, 1.0)
	
	#if height < 4.2 && velocity.y < 0.0:
		#velocity.y *= .8 + (height / 42)
		#velocity.y += 1.0 * delta
	
	if velocity.y < -0.001 and booster_throttle > 0.01:
		velocity.y *= 0.942 #when booster on and falling, bleed vertical velocity every physics frame
		if velocity.y < -0.42:
			velocity.y += 0.42
		else:
			velocity.y = 0.0
		
	#if booster_throttle == 1.0 && velocity.y < 0.01:
		#velocity.y = 0.0
	
	#if is_on_floor():
		#print("floor")

	# quit da game when ESC is pressed NOTE: erm move this
	if Input.is_action_just_pressed("esc"):
		get_tree().quit()

	# add energy to battery_storage_curr from reactor, clamping between (battery_storage_curr == battery_storage_max) and (fuel_kg == 0.0)
	var fuel_conversion_amt_this_frame = fuel_conversion_rate * delta
	fuel_conversion_amt_this_frame = clampf(fuel_conversion_amt_this_frame, 0.0, fuel_kg)
	var energy_potential = fuel_conversion_amt_this_frame * fuel_conversion_efficiency
	var energy_input_proportion = (battery_storage_max - battery_storage_curr) / energy_potential
	energy_input_proportion = clampf(energy_input_proportion, 0.0, 1.0)
	fuel_conversion_amt_this_frame *= energy_input_proportion
	#print(energy_potential * energy_input_proportion)
	battery_storage_curr += (energy_potential * energy_input_proportion)

	# shift the camera root's target position when the camera tilts up and down to prevent model from being in the middle of the screen
	var horizontal_vel : Vector2 = Vector2(velocity.x, velocity.z)
	camera_target.position.z = (camera_gimbal.rotation.x * (1.0 + (horizontal_vel.length() / 42.0)))

	movement_timer += delta
	# Get the input direction and handle the movement/decceleration.
	# As good practice, you should replace UI actions with custom gameplay actions.
	var input_dir := Input.get_vector("move_left", "move_right", "move_forward", "move_backward")
	var direction := (transform.basis * Vector3(input_dir.x, 0, input_dir.y)).normalized()
	if direction:
		var movement_force = SPEED
		if dashing: movement_force *= dashing_speed_multiplier
		if curr_dash_iframe < total_dash_iframes:
			movement_force *= 1.42
		elif dashing: # after our initial boost (with iframes) we need to subtract from the battery if we're still dashing.
			battery_storage_curr -= (movement_force * movement_cost_multiplier)
		#print(dashing)
		velocity.x = direction.x * movement_force
		velocity.z = direction.z * movement_force
		# scooch the camera whilst moving
		#print(direction.z)
		#camera_target.position.z = -abs(camera_gimbal.rotation.x)
		movement_timer = 0.0
	else: # slow to a stop
		var horizontal_velocity = Vector2(velocity.x, velocity.z)
		horizontal_velocity *= 0.9042
		
		velocity.x = horizontal_velocity.x #move_toward(velocity.x, 0, SPEED * 0.1)
		velocity.z = horizontal_velocity.y #move_toward(velocity.z, 0, SPEED * 0.1)
	
	# functionality on hold.
	# anticipate obstacles that can be hovered over, and engage booster accordingly ----------------
	# TODO: reclaim booster_throttle variable as general and use for this
	
	
	#var land_speed = Vector2(velocity.x, velocity.z).length()
	
	#if slope_probe_bottom.is_colliding() && land_speed > 4.2:
		#velocity.y += (12.2 - slope_probe_bottom_ray.length()) / 17.2
	# ----------------------------------------------------------------------------------------------
	
	
	# hovering -------------------------------------------------------------------------------------
	curr_hover_err = 0.0
	slope_hover_err = 0.0
	# this part: if upward slope / low obstacle detected and traveling at speed, use hover to boost up
	#var slope_probe_bottom_ray = slope_probe_bottom.get_collision_point() - slope_probe_bottom.global_position
	#var slope_probe_top_ray = slope_probe_top.get_collision_point() - slope_probe_top.global_position
	
	# dont ask
	#if slope_probe_bottom.is_colliding() && velocity.length() > 4.2 && 0.0 < slope_probe_bottom_ray.length() && slope_probe_bottom_ray.length() < 8.4 && (slope_probe_top_ray.length() > (slope_probe_bottom_ray.length() - 0.1) || !slope_probe_top.is_colliding()):
	#	slope_hover_err = (slope_probe_bottom.target_position.x - slope_probe_bottom_ray.length()) / (slope_probe_bottom.target_position.x * 2.0)
	
	# ok forget that last part ima try and actually do it here using obstacle_height_probe to detect inclines and modify hover height accordingly
	# set obstacle_height_probe position
	var land_speed = Vector2(velocity.x, velocity.z).length()
	
	var obstacle_distance = obstacle_distance_probe.get_collision_point().distance_to(obstacle_distance_probe.global_position)
	var obstacle_probe_dist = 0.0
	
	if obstacle_distance_probe.is_colliding():
		obstacle_probe_dist = minf(land_speed, obstacle_distance + 0.1)
	else:
		obstacle_probe_dist = land_speed
	
	ceiling_height_probe.position.x = obstacle_probe_dist
	obstacle_height_probe.position.x = obstacle_probe_dist
	
	
	var ceiling_height_local = (ceiling_height_probe.get_collision_point().y - ceiling_height_probe.global_position.y)
	
	obstacle_height_probe.position.y = minf(42.0, ceiling_height_local - 0.01)
	print(ceiling_height_local)
	
	
	var obstacle_height_probe_hit_point = obstacle_height_probe.get_collision_point()
	var hover_target = obstacle_height_probe_hit_point + Vector3(0,hover_height,0)
	slope_probe_top.target_position = slope_probe_top.to_local(hover_target + Vector3(0,1.417,0)) #(obstacle_height_probe_hit_point + Vector3(0,hover_height + 1.417,0), Vector3(0,1,0), true)
	slope_probe_bottom.target_position = slope_probe_bottom.to_local(hover_target) #(obstacle_height_probe_hit_point + Vector3(0,hover_height,0), Vector3(0,1,0), true)
	
	var hover_target_height_local = tail.to_local(hover_target).y
	#print(hover_target_height_local)
	
	if land_speed > 4.2 && hover_target_height_local > 0.0 && !slope_probe_bottom.is_colliding() && !slope_probe_top.is_colliding():
		#target_hover_err = clampf(hover_target_height_local / 4.0, 0.0, 1.42)
		velocity.y += (hover_target_height_local) / clampf(obstacle_probe_dist * obstacle_probe_dist, 2.0, 12.0)

	
	if !is_jumping:
		# normal hover
		if height < hover_height:
			curr_hover_err = hover_height - height
			
			#if velocity.y < 0.0: velocity.y = (height / hover_height)
			
			var raw_hover_derivative = (curr_hover_err - last_hover_err) / delta
			#print(raw_hover_derivative)
			#var smooth_hover_derivative_fac = minf(, 4.2)
			smooth_hover_derivative = lerp(smooth_hover_derivative, raw_hover_derivative, 0.5) #move_toward(smooth_hover_derivative, raw_hover_derivative, smooth_hover_derivative_fac)
			
			var hover_velocity = (kp * curr_hover_err) + (kd * smooth_hover_derivative)
			
			#print(hover_velocity)
			hover_velocity = clampf(hover_velocity, 0, 142)
			velocity.y += hover_velocity * delta
			#if hover_velocity > -0.001 and hover_velocity < 420.2: # trim harsh velocity additions
			
			#print(hover_velocity * delta)
			
			last_hover_err = curr_hover_err
		
		# dampen upward momentum to avoid excessive bounciness and soaring of hills
		if velocity.y > 0.0 && last_height < height:
			velocity.y *= .86 + (.14 - clampf(velocity.y / 180.0, 0.0, 0.14))
			#print(velocity.y / 200.0)
			#print("damping")
	# ----------------------------------------------------------------------------------------------

	# DEPRECATED:
	
	# demon ass damping function. (what does it even do? idfk)
	#velocity.y += (clampf(horizontal_vel.length() / 42.0, 0.0, 4.2) / clampf(height, 0.42, 42.2)) * 0.22
	
	
	# right of the "*=" is less than 1.0 when height is less than hover_height * 4.0, and we're going down. it's 0.8 at height 0.0
	# this effectively sucks 0-20% of the negative vertical velocity depending on how close to the ground we are, 0% (changing nothing) above 2.43ish
	#if velocity.y < 0.0:
		#velocity.y *= (0.6 + clampf(height * damping_factor, 0.0, 0.4))# * clampf(height, 0.00001, 1.0)
	#print(height)
	#if velocity.y < -0.62:
		#velocity.y += 0.62
	
	#if velocity.y < -14.42 && height < (hover_height * 1.42):
		#velocity.y *= 0.742
	
	#if (height < hover_height):
		#velocity.y += clampf(hover_height - height, 0.0, 0.42)
		
		#var slope_change_this_frame = (last_height - height) + (velocity.y * delta)
		#if (slope_change_this_frame < 0.42):
			#position.y += slope_change_this_frame / 2.0
			#print(slope_change_this_frame)
			#pass
		
		#var hover_boost = clampf(((0.82 - (height + 0.2)) * 4.2) - (velocity.y / 2.2), 0.0, 8.2)
		#velocity.y += hover_boost
		#print(hover_boost)
		#print(clampf((0.42 - height), 0.0, 0.62) - clampf(velocity.y / 42.2, 0.0, 0.72))
		#print(velocity.y)
	# /DEPRECATED

# --------------------------------------------------------------------------------------------------

	# dash when dash key is pressed
	if Input.is_action_just_pressed("dash") && (curr_dash_iframe > total_dash_iframes) && battery_storage_curr >= dash_battery_cost:
		curr_dash_iframe = 0
		dashing = true
		set_collision_layer_value(8, false)
		char_model.visible = false
		#print("turning off collision")
		battery_storage_curr -= dash_battery_cost
	
	if battery_storage_curr <= 0.0 or velocity.length() <= 1.0:
		dashing = false

	curr_dash_iframe += 1
# iframe execution:
	if (curr_dash_iframe == total_dash_iframes):
		set_collision_layer_value(8, true)
		char_model.visible = true

	# rotate the model to match the input vector ---------------------------------------------------
	if abs(velocity.x) > 0.001 or abs(velocity.z) > 0.001:
		input_vec = Vector2(velocity.x, velocity.z)
	
	var input_angle = atan2(input_vec.y, input_vec.x)
	var a = input_angle - model_angle
	if a > PI:
		a = -((2.0 * PI) - a)
	if a < -PI:
		a = ((2.0 * PI) + a)
	model_angle = model_angle + clampf((a / 4.2), -0.42, 0.42)
	
	# very important!! these 4 lines allow smooth wraparound of values, otherwise, they would have to "unwind" themselves after each 360 degree rotation
	model_angle = model_angle + PI
	model_angle = fmod(model_angle, (PI * 2.0))
	if model_angle < 0.0: model_angle = ((2.0 * PI) + model_angle)
	model_angle = model_angle - PI
	
	char_model.rotation.y = -model_angle
	# ----------------------------------------------------------------------------------------------

	# handle smooth camera zoom in and out:
	if (abs(camera_arm.spring_length - cam_distance_target) > 0.0001):
		camera_arm.spring_length = lerpf(camera_arm.spring_length, cam_distance_target, (4.2 * delta))

	# make body point ahead :)
	body.look_at(body_straight_ahead.global_position, Vector3(0, 1, 0), true)

	# this function tilts mc's body when moving
	tilt_body()

	# here we update the slope_probes to point the same direction as the body
	#slope_probe_top.look_at(straight_ahead.global_position, Vector3(0,1,0), true)
	#slope_probe_bottom.look_at(straight_ahead.global_position, Vector3(0,1,0), true)
	#slope_probe_top.rotation.y = slope_probe_top.rotation.y - PI/2
	#slope_probe_bottom.rotation.y = slope_probe_bottom.rotation.y - PI/2
	#slope_probe_bottom.rotation.y = body.rotation.y

	# called every physics frame to update interpolation points
	update_physics_interpolation_points()
	
	move_and_slide()

func fire_laser() -> void:
	pass

# body tilting while moving ----------------------------------------------------
const forward_y_val : float = -1.639
const full_dip_y_val : float = -4.0
var current_lerp_val : float = 0.0

func tilt_body() -> void:
	var next_lerp_val = (abs(velocity.z) + abs(velocity.x)) / 44.2
	if next_lerp_val > 0.02:
		var clamp_min = -next_lerp_val
		next_lerp_val += (velocity.y / 44.2)
		next_lerp_val = clampf(next_lerp_val, clamp_min, 1.0)
	else:
		next_lerp_val = clampf(next_lerp_val, 0.0, 1.0)
	var diff = current_lerp_val - next_lerp_val
	current_lerp_val -= (diff / 4.2)
	body_straight_ahead.position.y = lerp(forward_y_val, full_dip_y_val, current_lerp_val)
# ------------------------------------------------------------------------------

func _process(delta: float) -> void:
	move_cam_smooth(delta)
	move_model_smooth()

# smooth cam :) ----------------------------------------------------------------
func move_cam_smooth(delta: float):
	# derive our transform and rotation from camera_target, then set camera_root's attributes accordingly
	var lerped_target = camera_last_transform.interpolate_with(camera_target_transform, Engine.get_physics_interpolation_fraction())
	camera_root.global_transform = camera_root.global_transform.interpolate_with(lerped_target, (26 * delta))
	camera_root.global_rotation.y = camera_target.global_rotation.y
# ------------------------------------------------------------------------------

# update interpolation positions- 
func update_physics_interpolation_points():
	last_pos = target
	target = global_position + Vector3(0.0, 1.42, 0.0)
	
	camera_last_transform = camera_target_transform
	camera_target_transform = camera_target.global_transform

# smooth model movement --------------------------------------------------------
func move_model_smooth():
	char_model.global_position = lerp(last_pos, target, Engine.get_physics_interpolation_fraction())
# ------------------------------------------------------------------------------
